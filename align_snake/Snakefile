########################################################################################################
# align_snake
#   Snakemake workflow to use STARsolo to align and quantify 10x Chromium datasets
#   Written by David W. McKellar
########################################################################################################

import pandas as pd

########################################################################################################
# Config file
########################################################################################################
configfile:'config.yaml'
########################################################################################################
# Directories and locations
########################################################################################################
# DATADIR = config['DATADIR']
TMPDIR = config['TMPDIR'] # temporary files
DATADIR = config['DATADIR'] # outputs for STAR alignment, etc
REFDIR = config['REFDIR'] # Output for reference genomes

########################################################################################################
# Metadata
########################################################################################################
META = pd.read_csv(config['SAMPLE_SHEET'], na_filter=False)
META = META[list(META['include'])] #remove undesired samples ('include'==False)
META = META[list(META['file.format']!="ERR")] #remove samples that didn't download properly [YET!]

META = META[list(META['tissue']=="muscle")]
META = META[list(META['species']=="Homo sapiens")]

META = META[list(META['GSM.accession']!="NA")]
META = META[list(META['GSM.accession']!="")]
META = META.iloc[1:3,:] # subset to only download certain samples...

# Grab sample IDs and their associated fastqs
SAMPLES = META['GSM.accession'].unique()

R1_FQs = {}
R2_FQs = {}
for GSM in SAMPLES:
    TMP_SRR = META['SRR.accession'][list(META["GSM.accession"]==GSM)].values[0]
    TMP_SRR = TMP_SRR.split(";")
    R1_FQs[GSM] = [DATADIR+"/fastqs/"+SRR+"_R1.fastq.gz" for SRR in TMP_SRR]
    R2_FQs[GSM] = [DATADIR+"/fastqs/"+SRR+"_R2.fastq.gz" for SRR in TMP_SRR]

########################################################################################################
# Reference genome info
########################################################################################################
SPECIES = list(META['species']) #all lowercase and underscores (no spaces!)
SPECIES = [x.lower() for x in SPECIES]
SPECIES = [x.replace(' ', '_') for x in SPECIES]
SPECIES = pd.unique(SPECIES)
# print(SPECIES)

########################################################################################################
# Executables
########################################################################################################
STAR_EXEC = config['STAR_EXEC']
GGET_EXEC = config['GGET_EXEC']
FASTQC_EXEC = config['FASTQC_EXEC']
# TRIMGALORE_EXEC = config['TRIMGALORE_EXEC']
CUTADAPT_EXEC = config['CUTADAPT_EXEC']
#TODO- samtools, etc

########################################################################################################
rule all:
    input:
        expand('{REFDIR}/{SPECIES}/STAR/SAindex', REFDIR=REFDIR, SPECIES=SPECIES), # Reference genomes
        # expand('{DATADIR}/{sample}/Solo.out/Gene/filtered/matrix.mtx', DATADIR=config['DATADIR'], sample=SAMPLES),
        # expand('{DATADIR}/{sample}/Aligned.sortedByCoord.dedup.out.bam.bai', DATADIR=config['DATADIR'], sample=SAMPLES), # umi_tools deduplicated .bam **Note** this is super slow!! Only uncomment if NEEDED
        # expand('{DATADIR}/{sample}/Aligned.sortedByCoord.out.bam.bai', DATADIR=config['DATADIR'], sample=SAMPLES), #non-deduplicated .bam; used for saturation estimation
        expand('{DATADIR}/{sample}/preTrim_fastqc_R2_out', DATADIR=config['DATADIR'], sample=SAMPLES), # raw R2 fastQC results
        expand('{DATADIR}/{sample}/postTrim_fastqc_R2_out', DATADIR=config['DATADIR'], sample=SAMPLES) # adapter/polyA/ployG-trimmed R2 fastQC results
        # expand('{DATADIR}/{sample}/qualimap_out/qualimapReport.html', DATADIR=config['DATADIR'], sample=SAMPLES), # alignment QC qith qualimap plotgardener)

        # expand('{DATADIR}/{sample}/Unmapped_fastqc_out', DATADIR=config['DATADIR'], sample=SAMPLES), #fastQC results for unmapped reads
        # expand('{DATADIR}/{sample}/Solo.out/Gene/filtered/matrix.mtx.gz', DATADIR=config['DATADIR'], sample=SAMPLES), # count mats


#############################################
## Generate references w/ `gget`
#############################################
# Unzip the whitelist file if it hasn't been done yet
#TODO: change to download from somehwere? maybe look for a wget link?
#TODO: include this in `resources/chemistry_sheet.csv`
# rule gunzipWhitelists:
#     input:
#         config['CB_WHITELIST']+'.gz'
#     output:
#         config['CB_WHITELIST']
#     shell:
#         """
#         gunzip {input}
#         """

# Build reference genomes for STARsolo alignment/quantification
#TODO: parallelize across species!
rule build_refs:
    output:
        REF_METADATA = expand("{REFDIR}/{SPECIES}/STAR/metadata.json", REFDIR=config['REFDIR'], SPECIES=SPECIES),
        REF = expand("{REFDIR}/{SPECIES}/STAR/SAindex", REFDIR=config['REFDIR'], SPECIES=SPECIES) # Reference genomes
    threads:
        config['CORES_HI']
    run:
        for S in SPECIES:
            print(f"Downloading genome sequence and annotations for {S} to {REFDIR}/{S}")
            shell(
                f"""
                mkdir -p {REFDIR}/{S}
                cd {REFDIR}/{S}

                {GGET_EXEC} ref \
                --out {REFDIR}/{S}/metadata.json \
                --which gtf,dna \
                --download \
                {S}

                gunzip {REFDIR}/{S}/*.gz
                """
            )

            # Build reference for STAR
            print(f"Building STAR reference for {S}...\n")
            shell(
                f"""
                {STAR_EXEC} \
                --runThreadN {threads} \
                --runMode genomeGenerate \
                --genomeDir {REFDIR}/{S}/STAR \
                --genomeFastaFiles $(ls -t {REFDIR}/{S}/*.fa) \
                --sjdbGTFfile $(ls -t {REFDIR}/{S}/*.gtf) \
                --sjdbGTFfeatureExon exon

                pigz -p {threads} $(ls -t {REFDIR}/{S}/*.fa)
                pigz -p {threads} $(ls -t {REFDIR}/{S}/*.gtf)
                """
            )

#############################################
## Trimming and FastQC
#############################################

# Merge .fastq files (in case more than one sesquencing run was performed)
rule merge_fastqs:
    output:
        MERGED_R1_FQ = temp('{DATADIR}/{sample}/tmp/{sample}_R1.fq.gz'),
        MERGED_R2_FQ = temp('{DATADIR}/{sample}/tmp/{sample}_R2.fq.gz')
    params:
        TMP_DIR = '{DATADIR}/{sample}/tmp',
        R1_FQ = lambda wildcards: R1_FQs[wildcards.sample],
        R2_FQ = lambda wildcards: R2_FQs[wildcards.sample]
    threads:
        config['CORES_LO']
    run:
        if len(params.R1_FQ)==1 & len(params.R2_FQ)==1: # shell for single fastq input
            shell("cp {params.R1_FQ} {output.MERGED_R1_FQ}")
            shell("cp {params.R2_FQ} {output.MERGED_R2_FQ}")
        else: # shell enablinging multi-fast input; concatenate inputs
            print("Concatenating",len(params.R1_FQ), ".fastq's for", wildcards.sample)
            shell("mkdir -p {params.TMP_DIR}")
            shell("zcat {params.R1_FQ} > {params.TMP_DIR}/{wildcards.sample}_R1.fq")
            shell("zcat {params.R2_FQ} > {params.TMP_DIR}/{wildcards.sample}_R2.fq")
            shell("pigz -p {threads} {params.TMP_DIR}/*.fq")

# Check QC of reads before trimming
rule preTrim_FastQC_R2:
    input:
        MERGED_R2_FQ = '{DATADIR}/{sample}/tmp/{sample}_R2.fq.gz'
    output:
        fastqcDir = directory('{DATADIR}/{sample}/preTrim_fastqc_R2_out'),
        # fastqcReport = ''
    threads:
        config['CORES_LO']
        # min([config['CORES_LO'],8]) # 8 core max based on recommendations from trim_galore authors
    shell:
        """
        mkdir -p {output.fastqcDir}
        cd {output.fastqcDir}

        fastqc \
        --DATADIR {output.fastqcDir} \
        --threads {threads} \
        {input.MERGED_R2_FQ}
        """

rule trimPolyA_R2:
    input:
        MERGED_R1_FQ = '{DATADIR}/{sample}/tmp/{sample}_R1.fq.gz',
        MERGED_R2_FQ = '{DATADIR}/{sample}/tmp/{sample}_R2.fq.gz'
    output:
        A_TRIMMED_R1_FQ = temp('{DATADIR}/{sample}/tmp/{sample}_R1_Atrimmed.fq.gz'),
        A_TRIMMED_R2_FQ = temp('{DATADIR}/{sample}/tmp/{sample}_R2_Atrimmed.fq.gz'),
        POLYA_REPORT = '{DATADIR}/{sample}/cutadapt_polyA_report.txt'
    params:
        CUTADAPT_EXEC = CUTADAPT_EXEC,
        THREE_PRIME_R2_POLYA = "A"*100,
        FIVE_PRIME_R2 = "CCCATGTACTCTGCGTTGATACCACTGCTT" #10x TSO sequence
        # FIVE_PRIME_R2 = "TTCGTCACCATAGTTGCGTCTCATGTACCC" #rev 10x TSO sequence
    threads:
        config['CORES_LO']
        # min([config['CORES_LO'],8]) # 8 core max based on recommendations from trim_galore authors
    log:
        '{DATADIR}/{sample}/cutadapt_polyA_report.txt'
    shell:
        """
        # TSO & polyA trimming
        {params.CUTADAPT_EXEC} \
        --minimum-length 18 \
        -A {params.THREE_PRIME_R2_POLYA} \
 		-G {params.FIVE_PRIME_R2} \
        --pair-filter=any \
 		-o {output.A_TRIMMED_R1_FQ} \
        -p {output.A_TRIMMED_R2_FQ} \
        --cores {threads} \
        {input.MERGED_R1_FQ} {input.MERGED_R2_FQ} 1> {log}
        """
        # 2> {output.POLYA_REPORT}

#Additional trimming step, for 2-color Illumina chemistries (NextSeq, etc.)
rule trimPolyG_R2:
    input:
        A_TRIMMED_R1_FQ = '{DATADIR}/{sample}/tmp/{sample}_R1_Atrimmed.fq.gz',
        A_TRIMMED_R2_FQ = '{DATADIR}/{sample}/tmp/{sample}_R2_Atrimmed.fq.gz'
    output:
        FINAL_R1_FQ = temp('{DATADIR}/{sample}/tmp/{sample}_R1_final.fq.gz'),
        FINAL_R2_FQ = temp('{DATADIR}/{sample}/tmp/{sample}_R2_final.fq.gz'),
        POLYG_REPORT = '{DATADIR}/{sample}/cutadapt_polyG_report.txt'
    params:
        CUTADAPT_EXEC = CUTADAPT_EXEC,
        THREE_PRIME_R2_POLYG = "G"*100,
        FIVE_PRIME_R2 = "AAGCAGTGGTATCAACGCAGAGTACATGGG" # rev-comp of 10x TSO sequence
    threads:
        config['CORES_LO']
        # min([config['CORES_LO'],8]) # 8 core max based on recommendations from trim_galore authors
    log:
        log = '{DATADIR}/{sample}/cutadapt_polyG_report.txt'
    shell:
        """
        {params.CUTADAPT_EXEC} \
        --minimum-length 18 \
        -A {params.THREE_PRIME_R2_POLYG} \
 		-G {params.FIVE_PRIME_R2} \
        --pair-filter=any \
 		-o {output.FINAL_R1_FQ} \
        -p {output.FINAL_R2_FQ} \
        --cores {threads} \
        {input.A_TRIMMED_R1_FQ} {input.A_TRIMMED_R2_FQ} 1> {log.log}
        """

rule postTrim_FastQC_R2:
    input:
        FINAL_R2_FQ = '{DATADIR}/{sample}/tmp/{sample}_R2_final.fq.gz'
    output:
        fastqcDir = directory('{DATADIR}/{sample}/postTrim_fastqc_R2_out')
        # fastqcReport = ''
    threads:
        min([config['CORES_LO'],8]) # 8 core max
    shell:
        """
        mkdir -p {output.fastqcDir}
        cd {output.fastqcDir}

        fastqc \
        --DATADIR {output.fastqcDir} \
        --threads {threads} \
        {input.FINAL_R2_FQ}
        """

#############################################
## Alignment
#############################################
# Make output directory, align fastqs, and generate raw/filtered feature/cell-barcode matrices
#   Info for STARsolo command line paramaters: https://github.com/alexdobin/STAR/blob/master/docs/STARsolo.md

rule STARsolo_align:
    input:
        CB_WHITELIST = config['CB_WHITELIST'],#TODO- make chemistry-specific
        FINAL_R1_FQ = '{DATADIR}/{sample}/tmp/{sample}_R1_final.fq.gz',
        FINAL_R2_FQ = '{DATADIR}/{sample}/tmp/{sample}_R2_final.fq.gz',
        REF_LIST = expand('{REFDIR}/{SPECIES}/STAR_REF_FILE_NAME', REFDIR=REFDIR, SPECIES=SPECIES) # Reference genomes
    output:
        SORTEDBAM = '{DATADIR}/{sample}/Aligned.sortedByCoord.out.bam', #TODO: add temp()
        UNMAPPED1 = '{DATADIR}/{sample}/Unmapped.out.mate1',
        UNMAPPED2 = '{DATADIR}/{sample}/Unmapped.out.mate2',
        VELMAT = '{DATADIR}/{sample}/Solo.out/Velocyto/raw/spliced.mtx.gz',
        GENEMAT = '{DATADIR}/{sample}/Solo.out/Gene/raw/matrix.mtx.gz',
        GENEFULLMAT = '{DATADIR}/{sample}/Solo.out/GeneFull/raw/matrix.mtx.gz'
    params:
        CHEMISTRY = lambda wildcards: \
            META.loc[[wildcards.sample in srr_id for srr_id in META['SRR.accession']],'file.format'].values[0],
        DATADIR = config['DATADIR'],
        STAR_EXEC = config['STAR_EXEC'],
        # STAR_REF = config['STAR_REF'],#TODO-species-specific!
        UMIlen = config['UMIlen'], # pull from chemistry_sheet
        MEMLIMIT = config['MEMLIMIT']
    threads:
        config['CORES_LO']
    shell:
        """
        mkdir -p {params.DATADIR}/{wildcards.sample}

        {params.STAR_EXEC} \
        --runThreadN {threads} \
        --outFileNamePrefix {params.DATADIR}/{wildcards.sample}/ \
        --outSAMtype BAM SortedByCoordinate \
        --outSAMattributes NH HI nM AS CR UR CB UB GX GN sS sQ sM \
        --readFilesCommand zcat \
        --soloUMIlen {params.UMIlen} \
        --genomeDir {params.REF_LIST} \
        --genomeLoad LoadAndKeep \
        --limitBAMsortRAM={params.MEMLIMIT} \
        --readFilesIn {input.FINAL_R2_FQ} {input.FINAL_R1_FQ} \
        --clipAdapterType CellRanger4 \
        --outReadsUnmapped Fastx \
        --outFilterMultimapNmax 50 \
        --soloType CB_UMI_Simple \
        --soloCBwhitelist {input.CB_WHITELIST} \
        --soloCellFilter EmptyDrops_CR \
        --soloFeatures Gene GeneFull Velocyto \
        --soloMultiMappers EM
        """

        # compress outputs
        # shell(
        #     """
        #     gzip -qf {output.GENE}/raw/*
        #     gzip -qf {output.GENE}/filtered/*
        #
        #     gzip -qf {output.GENEFULL}/raw/*
        #     gzip -qf {output.GENEFULL}/filtered/*
        #
        #     gzip -qf {output.VEL}/raw/*
        #     gzip -qf {output.VEL}/filtered/*
        #     """
        # )

# Index the .bam produced by STAR
rule indexSortedBAM:
    input:
        SORTEDBAM = '{DATADIR}/{sample}/Aligned.sortedByCoord.out.bam'
    output:
        BAI = '{DATADIR}/{sample}/Aligned.sortedByCoord.out.bam.bai'
    threads:
        config['CORES_LO']
    shell:
        """
        samtools index -@ {threads} {input.SORTEDBAM}
        """


# Remove reads that don't have a corrected spot/cell barcode with samtools, then remove duplicates w/ **umi-tools**
## High mem usage? Check here! https://umi-tools.readthedocs.io/en/latest/faq.html
## **WARNING** this step is suuuupppppeeerrrr sloowwww. Don't run it if you don't need to!
rule umitools_dedupBAM:
    input:
        CB_WHITELIST = config['CB_WHITELIST'],
        SORTEDBAM = '{DATADIR}/{sample}/Aligned.sortedByCoord.out.bam'
    output:
        DEDUPBAM = '{DATADIR}/{sample}/Aligned.sortedByCoord.dedup.out.bam',
        TMPBAM = temp('{DATADIR}/{sample}/tmp.bam')
    params:
        OUTPUT_PREFIX='{DATADIR}/{sample}/umitools_dedup/{sample}',
        # TMPBAM = '{DATADIR}/{sample}/tmp.bam'
    threads:
        config['CORES_LO']
        #1
    log:
        '{DATADIR}/{sample}/umitools_dedup/dedup.log'
    shell:
        """
        samtools view -1 -b \
        -@ {threads} \
        --tag-file CB:{input.CB_WHITELIST} \
        {input.SORTEDBAM} \
        > {output.TMPBAM}

        samtools index \
        -@ {threads} \
        {output.TMPBAM}

        umi_tools dedup \
        -I {output.TMPBAM} \
        --extract-umi-method=tag \
        --umi-tag=UB \
        --cell-tag=CB \
        --method=unique \
        --per-cell \
        --unmapped-reads=discard \
        --output-stats={params.OUTPUT_PREFIX} \
        --log {log} \
        -S {output.DEDUPBAM}
        """

rule umitools_indexDedupBAM:
    input:
        SORTEDBAM = '{DATADIR}/{sample}/Aligned.sortedByCoord.dedup.out.bam'
    output:
        BAI = '{DATADIR}/{sample}/Aligned.sortedByCoord.dedup.out.bam.bai'
    threads:
        config['CORES_LO']
    shell:
        """
        samtools index -@ {threads} {input.SORTEDBAM}
        """

#############################################
## QC on STAR outputs
#############################################

## qualimap on aligned reads
rule qualimapQC:
    input:
        SORTEDBAM = '{DATADIR}/{sample}/Aligned.sortedByCoord.out.bam'
    output:
        qualimapDir = directory('{DATADIR}/{sample}/qualimap_out'),
        fastqcReport = '{DATADIR}/{sample}/qualimap_out/qualimapReport.html'
    params:
        # GENES_GTF = config['GENES_GTF'] #TODO Pull from downloaded gget files
    threads:
        1
        # config['CORES_LO']
    shell:
        """
        mkdir -p {output.qualimapDir}
        cd {output.qualimapDir}

        qualimap rnaseq \
        -bam {input.SORTEDBAM} \
        -gtf {params.GENES_GTF} \
        --sequencing-protocol strand-specific-forward \
        --sorted \
        --java-mem-size=6G \
        -DATADIR {output.qualimapDir} \
        -outformat html
        """

#############################################
## Unmapped read analyses
#############################################

# Compress and run fastqc on unmapped reads; switch names because of STAR weirdness
rule unmapped_fastqc:
    input:
        UNMAPPED1 = '{DATADIR}/{sample}/Unmapped.out.mate1',
        UNMAPPED2 = '{DATADIR}/{sample}/Unmapped.out.mate2'
    output:
        UNMAPPED1_FQ = '{DATADIR}/{sample}/Unmapped.out.mate1.fastq.gz',
        UNMAPPED2_FQ = '{DATADIR}/{sample}/Unmapped.out.mate2.fastq.gz',
        FQC_DIR = directory('{DATADIR}/{sample}/Unmapped_fastqc_out')
    params:
        FASTQC_EXEC = config['FASTQC_EXEC']
    threads:
        config['CORES_LO']
    shell:
        """
        mv {input.UNMAPPED1} {input.UNMAPPED2}.fastq
        mv {input.UNMAPPED2} {input.UNMAPPED1}.fastq

        pigz -p{threads} {input.UNMAPPED1}.fastq {input.UNMAPPED2}.fastq

        mkdir -p {output.FQC_DIR}

        {params.FASTQC_EXEC} -o {output.FQC_DIR} -t {threads} {output.UNMAPPED1_FQ} {output.UNMAPPED2_FQ}
        """
